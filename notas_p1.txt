NOTAS SOBRE LA PRACTICA 1

//Faltan explicar los detalles internos de la función
outImage adjustIntensity (inImage, inRange=[], outRange=[0, 1]):
    inImage -> La matriz que representa la imagen de entrada
    inRange -> Por defecto vacia, son los minimos y maximos niveles de gris en la entrada, si esta vacio se calcula a traves de la imagen
    outRange -> Rango de salida debe ser entre (0 1), por defecto (0 1)
    outImage -> Salida de la funcion, la imagen con la intensidad entre los valores especificados en outRange

outImage equalizeIntensity (inImage, nBins):
    inImage -> La matriz que representa la imagen de entrada
    nBins -> Numero de bins de la matriz de salida
    outImage -> Imagen ecualizada con nBins
Se calcula el histograma de la imagen con nBins como variable que indica los bins ,se calcula el porcentaje del peso de cada valor del histograma, para despues usarlo para calcular el acumulado,
que es necesario para la ecualizacion de la imagen, con estos datos usamos una funcion de una interpolacion normal para repartir los bins en la imagen ecualizada que sera devuelto por la funcion

//equivalente a cv2.filter2D
kernel filterImage (inImage,Kernel):
    inImage, outImage -> ...
    kernel -> Matriz PxQ con el kernel del filtro de entrada. Se asume que la posicion central del filtro esta en (P/2 + 1; Q/2 + 1).
    Aplica el kernel pixel a pixel y almacena el resultado en la variable image result que devuelve al finalizar el proceso, antes se precalculan los margenes que dependen del tamaño del kernel,
    y se crea la funcion fPad que crea un padding que permite las operaciones en las esquinas. Las variables p,q son las cordenadas del centro del kernel

gaussKernel1D(sigma):
    sigma ->
    kernel ->